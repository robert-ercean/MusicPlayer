package globalwaves.users.statistics;

import fileio.input.CommandInput;
import globalwaves.GlobalWaves;
import globalwaves.audiofiles.Song;
import globalwaves.users.listener.Listener;
import globalwaves.users.listener.player.Player;
import lombok.Getter;
import output.Output;
import output.WrappedStatsForOutput;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import static constants.Constants.HUNDRED;

@Getter
public class ArtistStats extends UserStatsObserver {
    private final Map<String, Integer> topAlbums;
    private final Map<String, Integer> topSongs;
    private final Map<String, Integer> topFans;
    private final MonetizationStats monetizationStats;
    /**
     * Map to store the revenue earned by each song
     * key -> the song's name
     * value -> revenue generated by the song
     * This map updates each time a listener cancels his premium subscription
     * (and it had listened to any song by this artist)
     * or when the program ends (all users that had not yet cancelled their premium subscription
     * will give their corresponding revenue to the specific songs)
     */
    private final Map<String, Double> songsRevenue;
    public ArtistStats(final String username) {
        this.topAlbums = new HashMap<>();
        this.topSongs = new HashMap<>();
        this.topFans = new HashMap<>();
        this.monetizationStats = new MonetizationStats();
        this.songsRevenue = new HashMap<>();
        super.username = username;
    }
    /**
     * displays the artist stats
     */
    @Override
    public Output display(final CommandInput command) {
        Output output = Output.getOutputTemplate(command);
        if (this.isEmpty()) {
            output.setMessage("No data to show for artist " + super.username + ".");
            return output;
        }
        WrappedStatsForOutput result = new WrappedStatsForOutput();
        // add the respective fields and limit each map to 5 entries without ordering
        result.setListeners(this.topFans.keySet().size());
        result.setTopAlbums(getSortedMap(topAlbums));
        result.setTopSongs(getSortedMap(topSongs));
        result.setTopFans(getSortedList(topFans));
        output.setResult(result);
        return output;
    }
    /**
     * parses the music events and updates the artist's stats
     */
    @Override
    public void update(final String eventType, final Player userPlayer, final int idx) {
        switch (eventType) {
            case "song", "playlist" -> processMusicEvent(userPlayer, eventType, idx);
            default -> throw new IllegalStateException("Unexpected value: " + eventType);
        }
    }

    /**
     * @return true if the artist has no stats to display
     */
    @Override
    public boolean isEmpty() {
        return topAlbums.isEmpty() && topSongs.isEmpty() && topFans.isEmpty();
    }

    /**
     * updates the stats for the artist when a song or a playlist is played
     */
    private void processMusicEvent(final Player userPlayer, final String eventType,
                                   final int idx) {
        Song song = eventType.equals("song") ? userPlayer.getCurrentSong()
                : userPlayer.getCurrentPlaylist().getSongsList().get(idx);
        if (song.getArtist().equals(super.username)) {
            topSongs.merge(song.getName(), 1, Integer::sum);
            topAlbums.merge(song.getAlbum(), 1, Integer::sum);
            Listener listener = GlobalWaves.getInstance().getListeners().get(userPlayer.getOwner());
            topFans.merge(listener.getUsername(), 1, Integer::sum);
        }
    }

    /**
     * calculates the total revenue generated by the artist's songs
     * and the most profitable song
     * @return the monetization statistics for the artist
     */
    public MonetizationStats getMonetizationStats() {
        double totalSongsRevenue = songsRevenue.values().stream().
                                   mapToDouble(Double::doubleValue).sum();
        /* round artist's total song revenue to 2 decimals */
        monetizationStats.setSongRevenue(Math.round(totalSongsRevenue * HUNDRED) / HUNDRED);
        monetizationStats.setMostProfitableSong(getSongWithMostRevenue().orElse("N/A"));
        return monetizationStats;
    }

    /**
     * @return the name of the song with the most revenue
     * easier to return "N/A" if there are no songs with revenue
     */
    public Optional<String> getSongWithMostRevenue() {
        return songsRevenue.entrySet().
                stream().max(Map.Entry.comparingByValue()).map(Map.Entry::getKey);
    }
}
